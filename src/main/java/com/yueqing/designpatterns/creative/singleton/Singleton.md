# 单例模式

## 一 意图

>保证一个类仅有一个实例，并提供一个访问他的全局访问点。

## 二 适用场景

1. 全局唯一的数据，比如配置信息，唯一ID生成器等等
2. 多并发模式下，适用单例可以替代分布式锁，等待队列等，提升性能
3. 全局变量也可以实现同样效果，但是全局变量不可控，可能会定义多个重复的，而且不可延迟加载。


## 三 实现方式

***进程内单例***

准确来说是同一个jvm进程内单例，且必须为同一个类加载器。

一般认为实现单例，至少需要下面三个条件：

***私有构造器 + 静态变量 + 静态方法***

**常见实现方式**
* 饿汉式  `HungrySingleton`
* 懒汉式 `LazySingleton`
  * 双重检查锁 + volatile
  * ~~synchronized 方法~~
* 静态内部类 `InnerClassSingleton`
* 枚举 `EnumSingleton`

***线程内单例***

使用`ThreadLocal`，`InheritableThreadLocal`,注意不可在多线程使用，及时移除，避免引用一直存在造成oom,以及引用对象未删除造成内存泄露。

***分布式单例***

## 四 优缺点
单例可有效解决全局唯一的问题，并且性能比较高。单例仅在首次请求单例对象时对其进行初始化，无须重复进行初始化创建对象，但这种模式天生就不适合扩展，
职责也不单一，是一种违背设计原则的设计。如果后面需要扩展成多例，就会比较麻烦。

还有就是如果单例模式得到滥用，代码就会不可控。一般认为业务场景中能使用到单例模式的场景不会太多，如果代码中充斥大量的单例类，
那就很可能是单例模式被滥用。

另外单例模式也难以编写单元测试，可测试性比较差，多线程下需要注意风险等等。


## 五 注意事项

1. 不可滥用单例模式。
2. 如果初始化比较简单，尽量使用饿汉式。
3. 如果使用延迟加载可能会导致部分问题在运行时才会暴露，无法在启动时提前预知。比如初始化redis配置，如果是延迟加载方式
   会导致运行时才发现redis配置错误无法连接，从而给线上带来很大的影响，使用延迟加载需慎重评估。
4. 如果是对外公开的代码，尽量做好防反射和防序列化处理。

## 六 应用场景

许多开发者将单例模式视为一种反模式。 因此它在 Java 代码中的使用频率正在逐步减少。
尽管如此， Java 核心程序库中仍有相当多的单例示例：
java.lang.Runtime#getRuntime()
java.awt.Desktop#getDesktop()
java.lang.System#getSecurityManager()

识别方法： 单例可以通过返回相同缓存对象的静态构建方法来识别。

## 七 与其他模式关系

***1 外观模式***
外观模式类通常可以转换为单例模式类， 因为在大部分情况下一个外观对象就足够了。

**2 享元模式**
如果你能将对象的所有共享状态简化为一个享元对象， 那么享元模式就和单例类似了。 但这两个模式有两个根本性的不同。只会有一个单例实体， 但是享元类
可以有多个实体， 各实体的内在状态也可以不同。单例对象可以是可变的。 享元对象是不可变的。

**3 抽象工厂、生成器、原型模式**
抽象工厂模式、 生成器模式和原型模式都可以用单例来实现。