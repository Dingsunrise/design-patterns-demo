# 原型模式

## 一 意图

> 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

## 二 适用场景

1 如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，
  创建新对象，以达到节省创建时间的目的。

2 如果一个类的实例只能有几种不同状态组合中的一种时，可以建立几种状态的原型，后续使用的地方直接进行克隆，比每次都实例化方便一些。

3 如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量。 我们可以通过创建对象原型，并在此基础上克隆一个对象，并改变一
  些结构以达到创建类型对象的目的。

4 动态加载。 此处有一定歧义。

## 三 实现方式

**常见实现方式**

* 浅拷贝 只会复制对象中基本数据类型数据和引用对象的内存地址，不会递归地复制引用对象，以及引用对象的引用对象。
* 深拷贝 复制对象中的基本数据且会将对象中的所有引用对象都复制一遍，生成完全独立的对象。所以，深拷贝比起浅拷贝来说，更加耗时，更加耗内存空间

浅拷贝实现方案，`clone,Apache BeanUtils,Spring BeanUtils`等。
深拷贝实现方案, 序列化，`Apache SerializableUtils,Gson,jackson,Dozer`等。

## 四 优缺点

可通过复制对象的方式，减少对象的创建过程，节省时间和成本，可以很方便的生成大对象或一些初始化比较麻烦的对象。但如果对象中依赖关系比较复杂，循环
依赖等，克隆起来就非常麻烦。

## 五 注意事项

1. 浅拷贝时，如果引用对象改动会影响原对象，所以需要慎重
2. 目前现有的各种拷贝方式都有不同程度的限制，使用时需要充分考虑。
3. java使用clone方法进行复制时，注意类中中引用对象是否也实现了clone方法，否则引用对象无法复制。

## 六 应用场景

Java的Cloneable接口就是立即可用的原型模式。任何类都可通过实现该接口来实现可被克隆的性质。

## 七 与其他模式关系

**1 抽象工厂模式**
抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。

**2 工厂方法模式**
原型并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 工厂方法基于继承， 但是它不需要初始化步骤。

**3 命令模式**
原型可用于保存命令模式的历史记录。

**4 组合和装饰模式**
大量使用组合模式和装饰模式的设计通常可从对于原型的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。

**5 备忘录模式**
有时候原型可以作为备忘录模式的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。

**6 单例模式**
原型可以使用单例模式来实现。