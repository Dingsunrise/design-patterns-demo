# 外观模式

## 一 简介

意图
>为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

简单来说就是假设有一个系统 A，提供了 a、b、c、d 四个接口。系统 B 完成某个业务功能，需要调用 A 系统的 a、b、d 接口。利用门面模式，我们提供一个
包裹 a、b、d 接口调用的门面接口 x，给系统 B 直接使用。

## 二 适用场景

 **1.解决易用性问题，如果需要一个指向复杂子系统的直接接口， 且该接口的功能有限， 则可以使用外观模式。**

   门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。比如，Linux 系统调用函数就可以看作一种“门面”。
   它是 Linux 操作系统暴露给开发者的一组“特殊”的编程接口，它封装了底层更基础的 Linux 内核调用。再比如，Linux 的 Shell 命令，实际上也可以
   看作一种门面模式的应用。它继续封装系统调用，提供更加友好、简单的命令，让我们可以直接通过执行命令来跟操作系统交互。

**2.解决性能问题**
通过将多个接口调用替换为一个门面接口调用，减少网络通信成本，提高 App 客户端的响应速度。

**3. 解决分布式事务问题**
比如用户注册需要支持事务，也就是说，创建用户和钱包的两个操作，要么都成功，要么都失败，不能一个成功、一个失败。要支持两个接口调用在一个事务中执行
，是比较难实现的，这涉及分布式事务问题。虽然我们可以通过引入分布式事务框架或者事后补偿的机制来解决，但代码实现都比较复杂。而最简单的解决方案是，
利用数据库事务或者 Spring 框架提供的事务（如果是 Java 语言的话），在一个事务中，执行创建用户和创建钱包这两个 SQL 操作。这就要求两个 SQL 操作
要在一个接口中完成，所以，我们可以借鉴门面模式的思想，再设计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个 SQL 操作。

**4. 将子系统组织为多层结构。**
创建外观来定义子系统中各层次的入口。 你可以要求子系统仅使用外观来进行交互， 以减少子系统之间的耦合。

## 三 实现方式

外观模式实现比较简答，声明一个外观接口，创建一些粗粒度的方法对外提供，底层封装各个子系统的接口的组合调用。

## 四 优缺点

外观模式可以让自己的代码独立于复杂子系统。但是外观可能成为与程序中所有类都耦合的上帝对象，渐渐变得臃肿，而且如果外观接口过多，又涉及到管理问题。
如果门面接口很多，我们可以在已有的接口之上，再重新抽象出一层，专门放置门面接口，从类、包的命名上跟原来的接口层做区分。如果门面接口特别多，并且很
多都是跨多个子系统的，我们可以将门面接口放到一个新的子系统中。

## 五 注意事项

完成接口设计，就相当于完成了一半的开发任务。只要接口设计得好，那代码就差不到哪里去。接口粒度设计得太大，太小都不好。太大会导致接口不可复用，太小
会导致接口不易用。在实际的开发中，接口的可复用性和易用性需要“微妙”的权衡。针对这个问题，我的一个基本的处理原则是，尽量保持接口的可复用性，但针对
特殊情况，允许提供冗余的门面接口，来提供更易用的接口。

所以外观接口要尽可能设计的可复用一些，如果比较臃肿，则可以拆出一个新的外观接口，外观接口如果比较多，可以在外观接口层级之上再加一层外观接口。

## 六 应用场景

使用 Java 开发的程序中经常会使用外观模式。 它在与复杂程序库和 API 协作时特别有用。

下面是一些核心 Java 程序库中的外观示例：
javax.faces.context.FacesContext 在底层使用了 LifeCycle、 ViewHandler 和 NavigationHandler 这几个类，但绝大多数客户端不知道。
javax.faces.context.ExternalContext在内部使用了ServletContext、HttpSession、HttpServletRequest、HttpServletResponse和其他一些类。

**识别方法：** 外观可以通过使用简单接口， 但将绝大部分工作委派给其他类的类来识别。 通常情况下， 外观管理着其所使用的对象的完整生命周期。


### 七 与其他模式关系

**适配器模式**
外观模式为现有对象定义了一个新接口， 适配器模式则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。

**抽象工厂模式**
当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用抽象工厂模式来代替外观。

**享元模式**
享元模式展示了如何生成大量的小型对象， 外观则展示了如何用一个对象来代表整个子系统。

**中介者模式**
外观和中介者模式的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。
外观为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。
中介者将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。

**单例模式**
外观类通常可以转换为单例模式类， 因为在大部分情况下一个外观对象就足够了。

**代理模式**
外观与代理模式的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点
上它与外观不同。