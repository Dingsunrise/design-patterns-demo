# 享元模式

## 一 简介

意图
>运用共享技术有效地支持大量细粒度的对象。
>
“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。

## 二 适用场景

1. 仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式。

应用该模式所获的收益大小取决于使用它的方式和情景。 它在下列情况中最有效：
 1. 程序需要生成数量巨大的相似对象
 2. 这将耗尽目标设备的所有内存
 3. 对象中包含可抽取且能在多个对象间共享的重复状态


## 三 实现方式

享元模式的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 Map 或者 List 来缓存已经创建好的享元对象，以达到复用的目的。

具体步骤可参考：

1. 将需要改写为享元的类成员变量拆分为两个部分：
   内在状态： 包含不变的、 可在许多对象中重复使用的数据的成员变量。
   外在状态： 包含每个对象各自不同的情景数据的成员变量
2. 保留类中表示内在状态的成员变量， 并将其属性设置为不可修改。 这些变量仅可在构造函数中获得初始数值。
3. 找到所有使用外在状态成员变量的方法， 为在方法中所用的每个成员变量新建一个参数， 并使用该参数代替成员变量。
4. 你可以有选择地创建工厂类来管理享元缓存池， 它负责在新建享元时检查已有的享元。 如果选择使用工厂， 客户端就只能通过工厂来请求享元， 它们需要将
   享元的内在状态作为参数传递给工厂。
5. 客户端必须存储和计算外在状态 （情景） 的数值， 因为只有这样才能调用享元对象的方法。 为了使用方便， 外在状态和引用享元的成员变量可以移动到单独的情景类中。


## 四 优缺点

如果程序中有很多相似对象， 那么你将可以节省大量内存。但可能可能需要牺牲执行速度来换取内存， 因为他人每次调用享元方法时都需要重新计算部分情景数据。
也会使代码会变得更加复杂。

## 五 注意事项
1. 享元模式需要注意对象状态不可被修改，不然会影响其他地方使用。

2. 享元模式有些情况下可能并不会如预期一样降低内存占用
   享元模式对 JVM 的垃圾回收并不友好。因为享元工厂类一直保存了对享元对象的引用，这就导致享
   元对象在没有任何代码使用的情况下，也并不会被 JVM 垃圾回收机制自动回收掉。因此，在某些情况下，如果对象的生命周期很短，也不会被密集使用，利用
   享元模式反倒可能会浪费更多的内存。所以，除非经过线上验证，利用享元模式真的可以大大节省内存，否则，就不要过度使用这个模式，为了一点点内存的节
   省而引入一个复杂的设计模式，得不偿失。
   所以使用享元模式一定要慎重

## 六 应用场景

享元模式只有一个目的： 将内存消耗最小化。 如果你的程序没有遇到内存容量不足的问题， 则可以暂时忽略该模式。
享元模式在核心 Java 程序库中的示例：
java.lang.Integer#valueOf(int) （以及 Boolean、 Byte、 Character、 Short、 Long 和 BigDecimal）

**识别方法**： 享元可以通过构建方法来识别， 它会返回缓存对象而不是创建新的对象。


### 七 与其他模式关系

**组合模式**
你可以使用享元模式实现组合模式树的共享叶节点以节省内存。

**外观模式**
享元展示了如何生成大量的小型对象，外观模式则展示了如何用一个对象来代表整个子系统。

**单例模式**
如果你能将对象的所有共享状态简化为一个享元对象， 那么享元就和单例模式类似了。但这两个模式有两个根本性的不同：
单例模式只会有一个单例实体， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。而且单例对象可以是可变的。 享元对象是不可变的。
应用单例模式是为了保证对象全局唯一。应用享元模式是为了实现对象复用，节省内存。缓存是为了提高访问效率，而非复用。池化技术中的“复用”理解为
“重复使用”，主要是为了节省时间，而且并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。