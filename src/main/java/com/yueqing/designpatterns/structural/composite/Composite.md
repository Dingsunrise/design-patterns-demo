# 组合模式

## 一 简介

意图
>将对象组合成树形结构以“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。

组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者。）可以统一单个对象和组合对象的处理逻辑。
组合模式跟我们之前讲的面向对象设计中的“组合关系（通过组合来组装两个类）”，完全是两码事。这里讲的“组合模式”，主要是用来处理树形结构数据。这里
的“数据”必须能表示成树形结构，这也导致了这种模式在实际的项目开发中并不那么常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作用，
能让代码变得非常简洁。

## 二 适用场景

1. 组合模式，将一组对象组织成树形结构，将单个对象和组合对象都看做树中的节点，以统一处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现。
   使用组合模式的前提在于，你的业务场景必须能够表示成树形结构。所以，组合模式的应用场景也比较局限，它并不是一种很常用的设计模式。。

2. 如果你希望客户端代码以相同方式处理简单和复杂元素， 可以使用该模式。组合模式中定义的所有元素共用同一个接口。 在这一接口的帮助下， 客户端不必
   在意其所使用的对象的具体类。

## 三 实现方式

1 确保应用的核心模型能够以树状结构表示。 尝试将其分解为简单元素和容器。 记住， 容器必须能够同时包含简单元素和其他容器。
2 声明组件接口及其一系列方法， 这些方法对简单和复杂元素都有意义。
3 创建一个叶节点类表示简单元素。 程序中可以有多个不同的叶节点类。
4 创建一个容器类表示复杂元素。 在该类中， 创建一个数组成员变量来存储对于其子元素的引用。 该数组必须能够同时保存叶节点和容器， 因此请确保将其
   声明为组合接口类型。
5 实现组件接口方法时， 记住容器应该将大部分工作交给其子元素来完成。
6 最后， 在容器中定义添加和删除子元素的方法。

叶子结点并不一定需要，可以公用一个组件类，没有子节点即可视为叶子结点。一般客户端使用组合模式都需要使用递归的方式。

## 四 优缺点

组合模式非常有利于处理树形结构数据，我们利用多态和递归机制更方便地使用复杂树结构。无需更改现有代码， 你就可以在应用中添加新元素， 使其成为对象树
的一部分。但对于功能差异较大的类，提供公共接口或许会有困难。在特定情况下，你需要过度一般化组件接口，使其变得令人难以理解。而且一般需要涉及递归操
作，增加复杂度。

## 五 注意事项

组合模式适合树形结构的数据，且不同对象直接差异不大，后续改动较小，不然直接使用组合模式会比较麻烦，后续也难以维护。处理递归时，注意不要陷入死循环。

## 六 应用场景

组合模式在 Java 代码中很常见,常用于表示与图形打交道的用户界面组件或代码的层次结构。
下面是一些来自 Java 标准程序库中的组合示例：
java.awt.Container#add(Component) （几乎广泛存在于 Swing 组件中）
javax.faces.component.UIComponent#getChildren() （几乎广泛存在于 JSF UI 组件中）

**识别方法：** 组合可以通过将同一抽象或接口类型的实例放入树状结构的行为方法来轻松识别。


### 七 与其他模式关系

**桥接模式、 状态模式和策略模式**
桥接模式、 状态模式和策略模式 （在某种程度上包括适配器模式） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。

**生成器模式**
你可以在创建复杂组合树时使用生成器模式， 因为这可使其构造步骤以递归的方式运行。

**职责链模式**
职责链模式通常和组合模式结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。

**迭代器模式**
你可以使用迭代器模式来遍历组合树。

**访问者模式**
你可以使用访问者模式对整个组合树执行操作。

**享元模式**
你可以使用享元模式实现组合树的共享叶节点以节省内存。

**装饰模式**
组合和装饰模式的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。
装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。
但是， 模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。
大量使用组合和装饰的设计通常可从对于原型模式的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。