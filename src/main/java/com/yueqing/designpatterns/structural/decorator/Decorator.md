# 装饰器模式

## 一 简介
**装饰器模式就是**
>动态地给一个对象添加一些额外的职责。

装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。
除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象
类或者接口。 


## 二 适用场景

1. 在无需修改代码的情况下即可使用对象， 且希望在运行时为对象新增额外的行为， 可以使用装饰模式。装饰能将业务逻辑组织为层次结构， 你可为各层创建
   一个装饰， 在运行时将各种不同逻辑组合成对象。 由于这些对象都遵循通用接口， 客户端代码能以相同的方式使用这些对象。
2. 如果用继承来扩展对象行为的方案难以实现或者根本不可行， 你可以使用该模式。许多编程语言使用 final最终关键字来限制对某个类的进一步扩展。 复用
   最终类已有行为的唯一方法是使用装饰模式： 用封装器对其进行封装。

3. 解决子类爆炸的问题。

## 三 实现方式
1. 确保业务逻辑可用一个基本组件及多个额外可选层次表示。

2. 找出基本组件和可选层次的通用方法。 创建一个组件接口并在其中声明这些方法。

3. 创建一个具体组件类， 并定义其基础行为。

4. 创建装饰基类， 使用一个成员变量存储指向被封装对象的引用。 该成员变量必须被声明为组件接口类型， 从而能在运行时连接具体组件和装饰。 装饰基类必须将所有工作委派给被封装的对象。

5. 确保所有类实现组件接口。

6. 将装饰基类扩展为具体装饰。 具体装饰必须在调用父类方法 （总是委派给被封装对象） 之前或之后执行自身的行为。

7. 客户端代码负责创建装饰并将其组合成客户端所需的形式。



## 四 优缺点
使用装饰器模式，无需创建新子类即可扩展对象的行为，你可以在运行时添加或删除对象的功能。也可以用多个装饰封装对象来组合几种行为。可以将实现了许多不
同行为的一个大类拆分为多个较小的类。
但是经过装饰之后，删除特定装饰行为比较困难，而且实现行为不受装饰栈顺序影响的装饰比较困难。另外如果需要很多层装饰，那初始化配置代码就会比较麻烦。

## 五 注意事项

注意装饰器增加行为时是否与其他装饰器行为冲突，不然会造成意料之外的问题，同时装饰层级不可过多，不然难以理解，初始化代码也会比较麻烦。

## 六 应用场景

装饰在 Java 代码中可谓是标准配置， 尤其是在与流式加载相关的代码中。
Java 核心程序库中有一些关于装饰的示例：
java.io.InputStream、 OutputStream、 Reader 和 Writer 的所有代码都有以自身类型的对象作为参数的构造函数。
java.util.Collections； checkedXXX()、 synchronizedXXX() 和 unmodifiableXXX() 方法。
javax.servlet.http.HttpServletRequestWrapper 和 HttpServletResponseWrapper

**识别方法**： 装饰可通过以当前类或对象为参数的创建方法或构造函数来识别。

### 七 与其他模式关系

**适配器模式**
适配器模式可以对已有对象的接口进行修改， 装饰模式则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。

**职责链模式**
职责链模式和装饰模式的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。
职责链模式的管理者可以相互独立地执行一切操作，还可以随时停止传递请求。另一方面，各种装饰可以在遵循基本接口的情况下扩展对象的行为。此外，装饰无法中断
请求的传递。

**组合模式**
组合模式和装饰的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。
装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。
但是， 模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。
大量使用组合和装饰的设计通常可从对于原型模式的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。

**策略模式**
装饰可让你更改对象的外表， 策略模式则让你能够改变其本质。

**代理模式**
装饰和代理有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的
不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。

适配器能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰则能为对象提供加强的接口。