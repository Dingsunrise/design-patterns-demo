# 职责链模式

## 一 简介

意图
>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

在职责链模式中，多个处理器（也就是刚刚定义中说的“接收对象”）依次处理同一个请求。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，
B 处理器处理完后再传递给 C 处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。

## 二 适用场景

1 当程序需要使用不同方式处理不同种类请求， 而且请求类型和顺序预先未知时， 可以使用职责链模式。

2 当必须按顺序执行多个处理者时， 可以使用该模式。

3 如果所需处理者及其顺序必须在运行时进行改变， 可以使用职责链模式。

4 也可对职责链进行变化，改成按照顺序每个处理者都需要进行处理。


***类图***



## 三 实现方式

**1 两种实现方式**
职责链模式一般常用的有两种实现方式
1 数组方式
  将所有Handle全部放到一个数组中，循环数组中的Handle调用其处理方法，如果可处理则直接处理并返回true,结束循环，如果不可处理，则返回false,继续循环。
2 链表方式
  每个Handle都保存下一个Handle的引用，调用其处理方法时判断是否可以处理，如果可以处理则直接处理，返回。如果不可处理则调用下一个Handle的处理方法进行处理。

**变体**
职责链模式还有个常用的变体
  针对一个请求，每个Handle都会进行处理，并且处理的结果传给下一个Handle。

**抽象父类**
Handle中的公用的部分操作可以抽取到一个公用的抽象基类里面。


## 四 优缺点
 职责链模式比较灵活，它对发起操作和执行操作的类进行解耦。可以控制请求处理的顺序，也可以在不更改现有代码的情况下在程序中新增处理者。但职责链模式
 也可能会造成部分请求无法被执行。所以需要做好补充操作。


## 五 注意事项
注意部分请求无法被处理的情况。

## 六 应用场景
职责链模式在 Java 程序中并不常见， 因为它仅在代码与对象链打交道时才能发挥作用。
一个值得注意的使用案例是依次访问过滤器。
下面是该模式在核心 Java 程序库中的一些示例：
javax.servlet.Filter#doFilter()
java.util.logging.Logger#log()
识别方法： 该模式可通过一组对象的行为方法间接调用其他对象的相同方法来识别， 而且所有对象都会遵循相同的接口。

职责链模式为了解耦代码，应对代码的复杂性，让代码满足开闭原则，提高代码的可扩展性，比如过滤敏感词，也常用在框架的开发中，为框架提供扩展点，
让框架的使用者在不修改框架源码的情况下，基于扩展点添加新的功能。实际上，更具体点来说，职责链模式最常用来开发框架的过滤器和拦截器，
如Servlet Filter（源码ApplicationFilterChain）、Spring Interceptor （源码HandlerExecutionChain）等等。

### 七 与其他模式关系

**1 职责链模式、 命令模式、 中介者模式和观察者模式**
职责链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：
 1. 职责链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。
 2. 命令在发送者和请求者之间建立单向连接。
 3. 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。
 4. 观察者允许接收者动态地订阅或取消接收请求。

**2 组合模式**
职责链通常和组合模式结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。

**3 命令模式**
职责链的管理者可使用命令模式实现。 在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作。
还有另外一种实现方式， 那就是请求自身就是一个命令对象。 在这种情况下， 你可以对由一系列不同上下文连接而成的链执行相同的操作。

**4 装饰模式**
职责链和装饰模式的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。职责链的管理者可以相互
独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种装饰可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。
