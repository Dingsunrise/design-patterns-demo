# 解释器模式

## 一 简介

**意图**
>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

解释器模式的代码实现比较灵活，没有固定的模板。我们前面也说过，应用设计模式主要是应对代码的复杂性，实际上，解释器模式也不例外。它的代码实现的核心
思想，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分成一些小的独立的单元，然后对每个单元进行解析，
最终合并为对整个语法规则的解析。

## 二 适用场景

1 解释器模式，其实就是用来实现根据语法规则解读“句子”的解释器。这里的“语言”不仅仅指我们平时说的中、英、日、法等各种语言。从广义上来讲，只要是能
承载信息的载体，我们都可以称之为“语言”,比如Spring的 SPEL。也可以适用于 对自定义各种规则的解析，比如入参的各种联合校验，API告警自定义规则等。


***类图***



## 三 实现方式

解释器模式简单来说，就是针对语法规则或自定义规则，拆分成各个小的单元，然后通过组合这些单元从而形成对整个语法或自定义规则的解析。


## 四 优缺点
 解释器模式比较灵活，清晰，可通过各种组合实现对复杂语法规则的解析。但也会造成大量小的方法或者类，查找麻烦。


## 五 注意事项

语法规则非常复杂时，解析器模式的代码也会跟着膨胀，变得难以管理和维护。

## 六 应用场景
解析器模式的应用场景比较少，一般用于语法规则解析的场景，比如Spring的 SPEL语法的解析。

### 七 与其他模式关系
**1 组合模式**
一般抽象语法树都是一个组合模式的实例。

**2 享元模式**
部分解释器可以共用

**3 迭代模式**
解析器可以使用一个迭代器遍历。

**4 访问者模式**
可在一个类中维护抽象语法树中个结点的行为。