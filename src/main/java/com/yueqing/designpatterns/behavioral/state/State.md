# 状态模式

## 一 简介

意图
> 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。

**别名：** 状态对象

这里再介绍一个状态机的概念
**有限状态机**

有限状态机，英文翻译是 Finite State Machine，缩写为 FSM，简称为状态机。状态机有 3 个组成部分：状态（State）、事件（Event）、
动作（Action）。其中，事件也称为转移条件（Transition Condition）。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，
不执行任何动作。

## 二 适用场景

1. 如果对象需要根据自身当前状态进行不同行为， 同时状态的数量非常多且与状态相关的代码会频繁变更的话， 可使用状态模式。模式建议你将所有特定于状态
   的代码抽取到一组独立的类中。 这样一来， 你可以在独立于其他状态的情况下添加新状态或修改已有状态， 从而减少维护成本。
2. 如果某个类需要根据成员变量的当前值改变自身行为， 从而需要使用大量的条件语句时， 可使用该模式。状态模式会将这些条件语句的分支抽取到相应状态类
   的方法中。 同时， 你还可以清除主要类中与特定状态相关的临时成员变量和帮手方法代码。
3. 当相似状态和基于条件的状态机转换中存在许多重复代码时， 可使用状态模式。状态模式让你能够生成状态类层次结构， 通过将公用代码抽取到抽象基类中来减少重复。
  
状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。正常业务中较少用到。
Spring 专门的状态机 [https://github.com/spring-projects/spring-statemachine](https://github.com/spring-projects/spring-statemachine)

## 三 实现方式

梳理业务中涉及到的所有状态，以及状态需要进行的不同行为，设计一个状态接口，再针对每个状态创建具体的状态类。

实现类似业务，一般称为状态机，针对状态机，一般有三种实现方式。
第一种实现方式叫分支逻辑法。利用 if-else 或者 switch-case 分支逻辑，参照状态转移图，将每一个状态转移原模原样地直译成代码。对于简单的状态机
来说，这种实现方式最简单、最直接，是首选。
第二种实现方式叫查表法。对于状态很多、状态转移比较复杂的状态机来说，查表法比较合适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。
第三种实现方式叫状态模式，也就是本文介绍的设计模式。对于状态并不多、状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机来
说，我们首选这种实现方式。


## 四 优缺点

状态模式可以将特定状态相关的代码放在单独的类中，无需修改已有状态类和上下文就能引入新状态，通过消除臃肿的状态机条件语句简化上下文代码等。但如果
状态机只有很少的几个状态， 或者很少发生改变， 那么应用该模式可能会显得小题大作。

## 五 注意事项

如果状态比较少，或很少改变尽量不要使用状态模式，

## 六 应用场景
在 Java 语言中， 状态模式通常被用于将基于 switch语句的大型状态机转换为对象。
这里是核心 Java 程序库中一些状态模式的示例：
javax.faces.lifecycle.LifeCycle#execute() （由FacesServlet控制： 行为依赖于当前 JSF 生命周期的阶段 （状态））
**识别方法：** 状态模式可通过受外部控制且能根据对象状态改变行为的方法来识别。

### 七 与其他模式关系

**桥接模式和策略模式**
桥接模式、 状态模式和策略模式 （在某种程度上包括适配器模式） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过
也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。

**策略模式**
状态可被视为策略的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 策略使得这些对象相互之间完全
独立， 它们不知道其他对象的存在。 但状态模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。