# 中介者模式

## 一 简介

意图
> 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互。

## 二 适用场景

1 当参与者之间的交互关系错综复杂，维护成本很高的时候，我们就需要考虑使用中介模式。
2 当一些对象和其他对象紧密耦合以致难以对其进行修改时，或者因过于依赖其他组件而无法在不同应用中复用时，可使用中介者模式。
3 如果为了能在不同情景下复用一些基本行为， 导致你需要被迫创建大量组件子类时， 可使用中介者模式。

## 三 实现方式

1 找到一组当前紧密耦合， 且提供其独立性能带来更大好处的类 （例如更易于维护或更方便复用）。

2 声明中介者接口并描述中介者和各种组件之间所需的交流接口。 在绝大多数情况下， 一个接收组件通知的方法就足够了。

3 如果你希望在不同情景下复用组件类， 那么该接口将非常重要。 只要组件使用通用接口与其中介者合作， 你就能将该组件与不同实现中的中介者进行连接。

4 实现具体中介者类。 该类可从自行保存其下所有组件的引用中受益。

5 你可以更进一步， 让中介者负责组件对象的创建和销毁。 此后， 中介者可能会与工厂或外观类似。

6 组件必须保存对于中介者对象的引用。 该连接通常在组件的构造函数中建立， 该函数会将中介者对象作为参数传递。

7 修改组件代码， 使其可调用中介者的通知方法， 而非其他组件的方法。 然后将调用其他组件的代码抽取到中介者类中， 并在中介者接收到该组件通知时执行这些代码。

## 四 优缺点

中介者模式可以将多个组件间的交流抽取到同一位置， 使其更易于理解和维护。你无需修改实际组件就能增加新的中介者，可以减轻应用中多个组件间的耦合情况。
也可以更方便地复用各个组件。
但是一段时间后， 中介者可能会演化成为大而复杂的上帝类，慢慢变的难以维护。

## 五 注意事项

中介者模式有比较大的副作用，所以使用中介模式的时候，我们要根据实际的情况，平衡对象之间交互的复杂度和中介类本身的复杂度。

## 六 应用场景

中介者模式在 Java 代码中最常用于帮助程序 GUI 组件之间的通信。 在 MVC 模式中， 控制器是中介者的同义词。
下面是核心 Java 程序库中该模式的一些示例：
java.util.Timer （所有 scheduleXXX()方法）
java.util.concurrent.Executor#execute()
java.util.concurrent.ExecutorService （ invokeXXX()和 submit()方法）
java.util.concurrent.ScheduledExecutorService （所有 scheduleXXX()方法）
java.lang.reflect.Method#invoke()

### 七 与其他模式关系

**责任链模式、 命令模式、 中介者模式和观察者模式**
责任链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：
1 责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。
2 命令在发送者和请求者之间建立单向连接。
3 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。
4 观察者允许接收者动态地订阅或取消接收请求。

**外观模式**
外观模式和中介者的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。
外观为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。
中介者将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。

**观察者模式**
中介者和观察者之间的区别往往很难记住。 在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用。 让我们来看看如何做到这一点。
中介者的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 观察者的目标是在对象之间建立动态的单向连接， 使得部分
对象可作为其他对象的附属发挥作用。

在观察者模式中，尽管一个参与者既可以是观察者，同时也可以是被观察者，但是，大部分情况下，交互关系往往都是单向的，一个参与者要么是观察者，要么是
被观察者，不会兼具两种身份。也就是说，在观察者模式的应用场景中，参与者之间的交互关系比较有条理。中介模式也是为了解耦对象之间的交互，所有的参与
者都只与中介进行交互。
除此之外，如果一个参与者状态的改变，其他参与者执行的操作有一定先后顺序的要求，这个时候，中介模式就可以利用中介类，通过先后调用不同参与者的方法，
来实现顺序的控制，而观察者模式是无法实现这样的顺序要求的。

有一种流行的中介者模式实现方式依赖于观察者。中介者对象担当发布者的角色，其他组件则作为订阅者，可以订阅中介者的事件或取消订阅。当中介者以
这种方式实现时，它可能看上去与观察者非常相似。
当你感到疑惑时，记住可以采用其他方式来实现中介者。例如，你可永久性地将所有组件链接到同一个中介者对象。这种实现方式和观察者并不相同，但这仍
是一种中介者模式。
假设有一个程序，其所有的组件都变成了发布者，它们之间可以相互建立动态连接。这样程序中就没有中心化的中介者对象， 而只有一些分布式的观察者。