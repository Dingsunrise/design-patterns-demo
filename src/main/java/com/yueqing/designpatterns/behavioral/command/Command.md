# 命令模式

## 一 简介

**意图**
>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。

**别名**： 动作，事务

命令模式用的最核心的实现手段，是将函数封装成对象。借助命令模式，我们可以将函数封装成对象。具体来说就是，设计一个包含这个函数的类，实例化一个
对象传来传去，这样就可以实现把函数像对象一样使用。从实现的角度来说，它类似我们之前讲过的回调。当我们把函数封装成对象之后，对象就可以存储下来，
方便控制执行。

## 二 适用场景

1 命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等等。将操作放入队列
中、 操作的执行或者远程执行操作

2 如果你需要通过操作来参数化对象， 可使用命令模式。
3 如果你想要实现操作回滚功能， 可使用命令模式。


***类图***



## 三 实现方式

**常见命令实现**
命令方式实现比较固定，一般定义一个统一的命令接口，和若干命令实现类，然后再定义一些接收者和命令实现类关联，进行处理请求，当然如果处理过程比较简单，
也可以不需要接收者类，直接在命令实现类中对请求进行处理。
最后还需要再定一个发送者对象，统一发送各种命令。

**宏命令实现**
有时我们经常需要一组命令去完成某个请求，这个时候可以把一组命令封装起来，组合成一个宏命令供外部调用。

**lambda**
命令模式可以配合lambda使用，一个lambda 就可以是一个命令。


## 四 优缺点
 命令模式可以有效的对发送者和接收者进行解耦。而且可对命令进行延迟执行，也可进行撤销。同时可灵活的组合多个命令从而完成比较复杂的操作。但命令模式
 也会导致代码变的比较复杂，所以不可以随意使用。


## 五 注意事项
命令模式容易是代码变的复杂，不那么清晰。所以如果选择使用的时候，需要多方考虑。

## 六 应用场景
命令模式在 Java 代码中很常见。 大部分情况下， 它被用于代替包含行为的参数化 UI 元素的回调函数， 此外还被用于对任务进行排序和记录操作历史记录等。
以下是在核心 Java 程序库中的一些示例：
java.lang.Runnable 的所有实现
javax.swing.Action 的所有实现

**识别方法**： 命令模式可以通过抽象或接口类型 （发送者） 中的行为方法来识别， 该类型调用另一个不同的抽象或接口类型 （接收者） 实现中的方法， 该实现
则是在创建时由命令模式的实现封装。 命令类通常仅限于一些特殊行为。

### 七 与其他模式关系

**职责链模式、中介者模式和观察者模式**
职责链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：
 1. 职责链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。
 2. 命令在发送者和请求者之间建立单向连接。
 3. 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。
 4. 观察者允许接收者动态地订阅或取消接收请求。
 5. 职责链的管理者可使用命令模式实现。 在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作。还有另外一种实现方式， 那就是请求
    自身就是一个命令对象。 在这种情况下， 你可以对由一系列不同上下文连接而成的链执行相同的操作。

**备忘录模式**
你可以同时使用命令和备忘录模式来实现 “撤销”。 在这种情况下， 命令用于对目标对象执行各种不同的操作， 备忘录用来保存一条命令执行前该对象的状态。

**策略模式**
命令和策略模式看上去很像， 因为两者都能通过某些行为来参数化对象。 但是， 它们的意图有非常大的不同。你可以使用命令来将任何操作转换为对象。 操作
的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等。另一方面， 策略通常可用于
描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。
在策略模式中，不同的策略具有相同的目的、不同的实现、互相之间可以替换。比如，BubbleSort、SelectionSort 都是为了实现排序的，只不过一个是用
冒泡排序算法来实现的，另一个是用选择排序算法来实现的。而在命令模式中，不同的命令具有不同的目的，对应不同的处理逻辑，并且互相之间不可替换。

**原型模式**
原型模式可用于保存命令的历史记录。

**访问者模式**
你可以将访问者模式视为命令模式的加强版本， 其对象可对不同类的多种对象执行操作。
