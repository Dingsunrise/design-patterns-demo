# 策略模式

## 一 简介

意图
> 定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。


## 二 适用场景

1. 解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多
2. 当你想使用对象中各种不同的算法变体， 并希望能在运行时切换算法时， 可使用策略模式。
3. 当你有许多仅在执行某些行为时略有不同的相似类时， 可使用策略模式。策略模式让你能将不同行为抽取到一个独立类层次结构中， 并将原始类组合成同一
   个， 从而减少重复代码。
4. 如果算法在上下文的逻辑中不是特别重要，使用该模式能将类的业务逻辑与其算法实现细节隔离开来。
5. 当类中使用了复杂条件运算符以在同一算法的不同变体中切换时， 可使用该模式。策略模式将所有继承自同样接口的算法抽取到独立类中， 因此不再需要条件语句。


## 三 实现方式
一个完整的策略模式包含策略的定义、创建、使用。
策略模式的实现比较简单，定义一个策略接口，然后针对每种策略创建一个策略类。

策略模式的创建一般是通过工厂方法模式进行创建，因为策略模式都是实现同一个接口，所以可以借助一些技巧创建工厂类：
1 java项目
  通过 ServiceLoader.load 的方式生成工厂类

2 Spring项目
  实现 ApplicationContextAware接口，通过ApplicationContext->getBeansOfType 来获取所有的策略类


## 四 优缺点

策略模式比较灵活，将调用方与具体的策略解耦，可以随时增加或删除策略，也可以在运行时更换策略。对于复杂代码来说，策略模式还能让其满足开闭原则，
添加新策略的时候，最小化、集中化代码改动，减少引入 bug 的风险。

但如果策略基本不会改动，那没必要单独引入策略模式，而且如果策略的实现比较简单，也可以直接使用lambda代替策略类。

## 五 注意事项

使用策略模式时，必须先了解清楚每个策略，如果策略比较多，维护就会有些麻烦。

## 六 应用场景
策略模式在 Java 代码中很常见。 它经常在各种框架中使用， 能在不扩展类的情况下向用户提供改变其行为的方式。
Java 8 开始支持 lambda 方法， 它可作为一种替代策略模式的简单方式。

这里有一些核心 Java 程序库中策略模式的示例：
对 java.util.Comparator#compare() 的调用来自 Collections#sort().
javax.servlet.http.HttpServlet：  service()方法， 还有所有接受 HttpServletRequest和 HttpServletResponse对象作为参数的 doXXX()方法。
javax.servlet.Filter#doFilter()

**识别方法：** 策略模式可以通过允许嵌套对象完成实际工作的方法以及允许将该对象替换为不同对象的设置器来识别。

### 七 与其他模式关系

**桥接模式和状态模式**
桥接模式、 状态模式和策略模式 （在某种程度上包括适配器模式） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过
也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。

**命令模式**
命令模式和策略看上去很像，因为两者都能通过某些行为来参数化对象。但是，它们的意图有非常大的不同。
你可以使用命令来将任何操作转换为对象。操作的参数将成为对象的成员变量。你可以通过转换来延迟操作的执行、将操作放入队列、保存历史命令或者向远
程服务发送命令等。
另一方面， 策略通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。

**装饰模式**
装饰模式可让你更改对象的外表， 策略则让你能够改变其本质。

**模板方法模式**
模板方法模式基于继承机制： 它允许你通过扩展子类中的部分内容来改变部分算法。 策略基于组合机制： 你可以通过对相应行为提供不同的策略来改变对象的
部分行为。 模板方法在类层次上运作， 因此它是静态的。 策略在对象层次上运作， 因此允许在运行时切换行为。

**状态模式**
状态可被视为策略的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 策略使得这些对象相互之间完全
独立， 它们不知道其他对象的存在。 但状态模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。